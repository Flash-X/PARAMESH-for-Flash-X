!----------------------------------------------------------------------
!! 
! PARAMESH - an adaptive mesh library.
! Copyright (C) 2003
!
! Use of the PARAMESH software is governed by the terms of the
! usage agreement which can be found in the file
! 'PARAMESH_USERS_AGREEMENT' in the main paramesh directory.
!----------------------------------------------------------------------

!!REORDER(5): unk, facevar[xyz], tfacevar[xyz]
!!REORDER(4): recvar[xyz]f
#include "paramesh_preprocessor.fh"


      module amr_mg_common

      use tree
      use paramesh_dimensions

      public :: nodetype_old
      integer, allocatable, save :: nodetype_old(:)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! multigrid support
      public :: to_be_data_type
      type to_be_data_type
        integer, pointer, dimension(:,:,:) :: & 
     &      to_be_sent_guard_mg, & 
     &      to_be_sent_prol_mg, & 
     &      to_be_sent_flux_mg, & 
     &      to_be_sent_restrict_mg, & 
     &      to_be_received_guard_mg, & 
     &      to_be_received_prol_mg, & 
     &      to_be_received_flux_mg, & 
     &      to_be_received_restrict_mg
      end type to_be_data_type

      public :: to_be_levels
      type(to_be_data_type), save, dimension(:), allocatable :: & 
     &      to_be_levels

      public :: pe_source_guard_mg
      public :: pe_source_prol_mg
      public :: pe_source_flux_mg
      public :: pe_source_restrict_mg
      integer, save,dimension(:,:),allocatable :: pe_source_guard_mg
      integer, save,dimension(:,:),allocatable :: pe_source_prol_mg
      integer, save,dimension(:,:),allocatable :: pe_source_flux_mg
      integer, save,dimension(:,:),allocatable & 
     &                                   :: pe_source_restrict_mg

      public :: commatrix_guard_mg,commatrix_prol_mg
      public :: commatrix_flux_mg
      public :: commatrix_restrict_mg
      public :: laddress_guard_mg,laddress_prol_mg,laddress_flux_mg
      public :: laddress_restrict_mg
      integer, save,dimension(:,:,:),allocatable :: commatrix_guard_mg
      integer, save,dimension(:,:,:),allocatable :: commatrix_prol_mg
      integer, save,dimension(:,:,:),allocatable :: commatrix_flux_mg
      integer, save,dimension(:,:,:),allocatable :: & 
     &                                         commatrix_restrict_mg

      integer, allocatable, save,dimension(:,:,:) & 
     &                                          :: laddress_guard_mg
      integer, allocatable, save,dimension(:,:,:) & 
     &                                          :: laddress_prol_mg
      integer, allocatable, save,dimension(:,:,:) & 
     &                                          :: laddress_flux_mg
      integer, allocatable, save,dimension(:,:,:) & 
     &                                          :: laddress_restrict_mg

      public :: largest_no_of_blocks_guard_mg
      public :: largest_no_of_blocks_prol_mg
      public :: largest_no_of_blocks_flux_mg
      public :: largest_restrict_mg
      public :: num_recipient_pes_guard_mg
      public :: num_recipient_pes_prol_mg,num_recipient_pes_flux_mg
      public :: num_recipient_pes_restrict_mg
      public :: strt_guard_mg,strt_prol_mg,strt_flux_mg
      public :: strt_restrict_mg
      integer,dimension(:),allocatable,save :: & 
     & largest_no_of_blocks_guard_mg
      integer,dimension(:),allocatable,save :: & 
     & largest_no_of_blocks_prol_mg
      integer,dimension(:),allocatable,save :: & 
     & largest_no_of_blocks_flux_mg
      integer,dimension(:),allocatable,save :: & 
     & largest_restrict_mg
      integer,dimension(:),allocatable,save :: num_recipient_pes_guard_mg
      integer,dimension(:),allocatable,save :: num_recipient_pes_prol_mg
      integer,dimension(:),allocatable,save :: num_recipient_pes_flux_mg
      integer,dimension(:),allocatable,save :: & 
     & num_recipient_pes_restrict_mg
      integer,dimension(:),allocatable,save :: strt_guard_mg
      integer,dimension(:),allocatable,save :: strt_prol_mg
      integer,dimension(:),allocatable,save :: strt_flux_mg
      integer,dimension(:),allocatable,save :: strt_restrict_mg

      !amr_mg_min_required_level is used by our hybrid (Multigrid + 
      !single level FFT) strategy to reduce the number of calls to
      !mpi_morton_bnd_XXX.  The hybrid solver will generally set it 
      !equal to the finest fully refined level in the AMR grid.
      !By default though, it has the value of 1 which is the required 
      !value for pure Multigrid.
      public :: amr_mg_min_required_level
      integer, save :: amr_mg_min_required_level = 1
      
      end module amr_mg_common
      
